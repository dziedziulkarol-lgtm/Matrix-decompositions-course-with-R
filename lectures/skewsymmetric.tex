\documentclass[12pt]{article}

% --- Preambuła (PL + matematyka) ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[polish]{babel}
\usepackage{lmodern}
\usepackage{geometry}
\geometry{margin=1in}
\usepackage{amsmath,amsthm}
\let\lll\undefined % unikamy konfliktu z babel
\usepackage{amssymb,mathtools,bm}
\usepackage{enumitem}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, urlcolor=blue, citecolor=teal}
\usepackage{tikz}

\title{Kanoniczny rozkład macierzy rzeczywistych antysymetrycznych\\[2mm]
{\large (blokowa forma ortogonalna, własności i kontekst symplektyczny)}}
\author{}
\date{}

% --- Środowiska twierdzeń ---
\theoremstyle{plain}
\newtheorem{theorem}{Twierdzenie}
\newtheorem{proposition}[theorem]{Propozycja}
\newtheorem{corollary}[theorem]{Wniosek}
\theoremstyle{remark}
\newtheorem*{remark}{Uwaga}

% --- Notacja skrótowa ---
\newcommand{\R}{\mathbb{R}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\ii}{\mathrm{i}}

\begin{document}
\maketitle

\section*{Cel}
W ramach wykładu o rozkładach macierzowych przedstawiamy \emph{kanoniczny rozkład ortogonalny}
macierzy rzeczywistych antysymetrycznych $A^T=-A$.  Tę przestrzeń oznaczamy
\[
\mathfrak{so}(n)=\{X\in\R^{n\times n} : X^T=-X\}.
\]
Rozkład ten ujawnia pary $2\times2$ bloków
\[
J(\mu)=\begin{bmatrix}0&-\mu\\ \mu&0\end{bmatrix},\qquad \mu\ge 0,
\]
oraz ewentualny blok zerowy, co prowadzi do szeregu klasycznych własności
(wartości własne, rząd, pfaffian) i naturalnie łączy temat z rozkładami SVD
oraz z geometrią symplektyczną (poprzez macierz $J$).

\section{Spektralna anatomia: idea dowodu}
Kluczowe fakty:
\begin{itemize}[itemsep=2pt]
  \item $A$ jest \emph{normalna} ($A^TA=AA^T$), więc jest \emph{unitarnie diagonalizowalna} nad $\C$.
  \item Wartości własne $A$ są czysto urojone lub $0$ i występują w parach $\pm \ii \mu$ ($\mu\ge 0$).
  \item Parę sprzężonych wektorów własnych można zrealizować jako \emph{rzeczywistą} bazę $2$-wymiarową,
        w której $A$ ma blok $J(\mu)$.
\end{itemize}

\begin{theorem}[Kanoniczna forma blokowa]
Niech $A\in\R^{n\times n}$ oraz $A^T=-A$. Wtedy istnieje macierz ortogonalna $Q\in O(n)$
taka, że
\[
Q^TAQ=\mathrm{diag}\big(J(\mu_1),\dots,J(\mu_k),0_{m}\big),
\]
gdzie $\mu_j>0$, $2k+m=n$, a $0_m$ oznacza blok zerowy rozmiaru $m\times m$.
\end{theorem}

\begin{proof}
Ponieważ $A$ jest normalna, istnieje unitarna $U\in\C^{n\times n}$ z
\[
U^*AU=\mathrm{diag}\big(\ii\mu_1,-\ii\mu_1,\dots,\ii\mu_k,-\ii\mu_k,\underbrace{0,\dots,0}_{m}\big),
\quad \mu_j>0.
\]
Niech $v\in\C^n$ spełnia $Av=\ii\mu v$. Rozłóż $v=x+\ii y$ z $x,y\in\R^n$.
Wówczas
\[
A(x+\ii y)=\ii\mu(x+\ii y)\;\Longrightarrow\;
\begin{cases}
Ax=-\mu y,\\
Ay=\mu x.
\end{cases}
\]
Zatem w bazie $(x,y)$ ograniczenie $A$ do $\mathrm{span}\{x,y\}$ ma macierz $J(\mu)$.
Powtarzamy konstrukcję dla każdej pary wartości własnych $\pm\ii\mu_j$, ortogonalizując
kolejno otrzymywane pary $(x_j,y_j)$ względem iloczynu skalarnego w $\R^n$ i rozszerzając
do bazy ortonormalnej przestrzeni $\R^n$. W wektorowej części odpowiadającej wartości
własnej $0$ wybieramy dowolną bazę ortonormalną, gdzie $A$ działa zerowo. Złożenie
tych wektorów w kolumny daje $Q\in O(n)$ o żądanej własności.
\end{proof}

\begin{corollary}[Wartości własne, rząd, pfaffian]
Dla $A^T=-A$ zachodzi:
\begin{enumerate}[label=(\alph*),itemsep=2pt]
  \item Widmo: $\sigma(A)\subset \{\pm \ii \mu_1,\dots,\pm \ii \mu_k,0\}$ z $\mu_j>0$.
  \item $\,\mathrm{rank}(A)=2k$ jest parzysty; $\dim\ker(A)=m$.
  \item Jeśli $n$ jest nieparzyste, to $\det(A)=0$. Jeśli $n$ jest parzyste, to
        $\det(A)=\mathrm{Pf}(A)^2\ge 0$ (pfaffian $\mathrm{Pf}(A)$).
\end{enumerate}
\end{corollary}

\begin{remark}[SVD i normy]
Z $Q^TAQ=\mathrm{diag}(J(\mu_1),\dots)$ otrzymujemy $A^TA=(-A)^2=\mathrm{diag}(\mu_1^2 I_2,\dots)$, która jest dodatnio-półokreślona
więc \emph{wartości osobliwe} $A$ to $\{\mu_1,\mu_1,\dots,\mu_k,\mu_k,\underbrace{0,\dots,0}_{m}\}$.
W szczególności $\|A\|_2=\max_j \mu_j$.
\end{remark}

\section{Rysunek bloków}
Poniżej schematyczna wizualizacja bloku $J(\mu)$ w przekątni (pozostałe wpisy zerowe pomijamy).
\begin{center}
\begin{tikzpicture}[scale=0.9]
  \draw[thick] (0,0) rectangle (6,6);
  \draw[thick,fill=gray!10] (0.6,5.4) rectangle (2.6,3.4);
  \node at (1.6,4.6) {$\begin{bmatrix}0&-\mu\\ \mu&0\end{bmatrix}$};
  \draw[dashed] (3.2,5.8) -- (3.2,0.2);
  \draw[dashed] (0.2,3.0) -- (5.8,3.0);
  \node[anchor=west] at (3.3,5.4) {$\ddots$};
  \node[anchor=west] at (3.3,3.8) {$\ddots$};
  \node at (4.9,1.1) {$0_m$};
\end{tikzpicture}
\end{center}

\section{Uwaga o związku z symplektyką }
Standardowa macierz symplektyczna ma postać
\[
J=\begin{bmatrix}0&-I_n\\ I_n&0\end{bmatrix},\qquad J^T=-J.
\]
\emph{Grupa symplektyczna} $\mathrm{Sp}(2n,\R)$ to macierze $S$ spełniające $S^T J S=J$,
a jej algebra Liego to
\[
\mathfrak{sp}(2n,\R)=\{X\in\R^{2n\times 2n}:\ X^T J+JX=0\}.
\]
\textbf{Uwaga:} warunek $X^T=-X$ (zwykła antysymetria) generuje przez wykładnik grupę
\emph{ortogonalną} $O(n)$, bo $\frac{d}{dt}\big((e^{tX})^T e^{tX}\big)=0$. Natomiast
warunek \emph{$J$-antysymetrii} $X^T J + J X=0$ gwarantuje, że $e^{tX}$ jest symplektyczna:
\[
\frac{d}{dt}\big((e^{tX})^T J e^{tX}\big)
=(e^{tX})^T(X^T J + J X)e^{tX}=0.
\]
Związek z naszym rozkładem: bloki $J(\mu)=\mu\begin{bmatrix}0&-1\\1&0\end{bmatrix}$ są skalowanymi
kopiami $2\times2$ części $J$, co tłumaczy podobieństwo \emph{kształtu} kanonicznych bloków,
ale \emph{warunek Lie’owski} dla symplektyki to $X^T J + J X=0$ (nie $X^T=-X$).

\section*{Kącik angielski}
\begin{itemize}[leftmargin=*,itemsep=2pt]
  \item \emph{skew-symmetric matrix} — macierz antysymetryczna ($A^T=-A$).
  \item \emph{special orthogonal group} --- grupa macierzy ortogonalnych specjalnych $SO(n)$.
  \item \emph{orthogonal similarity} — podobieństwo przez macierz ortogonalną ($Q^TAQ$).
  \item \emph{real Schur decomposition} --- rzeczywista postać Schura.
  \item \emph{canonical $2\times2$ blocks} — kanoniczne bloki $J(\mu)$ na przekątnej.
  \item \emph{pfaffian} — pfaffian; $\det(A)=\mathrm{Pf}(A)^2$ dla $n$ parzystego.
  \item \emph{symplectic Lie algebra} — algebra Liego $\mathfrak{sp}(2n,\R): X^T J+JX=0$.
\end{itemize}

\section*{Zadania}

\begin{enumerate}[itemsep=4pt]

  \item \textbf{Generator ortogonalny.}
  Niech $X^T=-X$. Pokaż, że $e^{tX}\in O(n)$, korzystając z
  \[
  g(t)=(e^{tX})^T e^{tX},\qquad g'(t)=0,\quad g(0)=I.
  \]
  \emph{Wniosek:} $e^{tX}\in SO(n)$, bo $\det(e^{tX})=e^{t\,\mathrm{tr}(X)}=1$.

  \item \textbf{Generator symplektyczny.}
  Niech $X^T J + J X=0$. Pokaż, że
  \[
  h(t)=(e^{tX})^T J e^{tX}
  \]
  jest stałe równe $J$ (czyli $e^{tX}\in \mathrm{Sp}(2n,\R)$). \emph{Wniosek:} $\det(e^{tX})=1$.

  \item \textbf{Bloki $J(\mu)$ a SVD – aproksymacja optymalna.}
  Niech $A^T=-A$ i $Q^TAQ=\mathrm{diag}(J(\mu_1),\dots,J(\mu_k),0_m)$ z $\mu_1\ge\cdots\ge\mu_k>0$.
  Udowodnij, że najlepsza aproksymacja rzędu $2r$ w normie Frobeniusa otrzymuje się,
  zachowując $r$ największych bloków $J(\mu_j)$, a błąd wynosi
  \[
  \min_{\mathrm{rank}\le 2r}\|A-\tilde A\|_F^2
  \;=\; 2\sum_{j>r}\mu_j^2,
  \]
  (Eckart–Young–Mirsky; każda $\mu_j$ to para wartości osobliwych).

  \item \textbf{Pfaffian i wyznacznik.}
  Pokaż, że dla bloku $J(\mu)$ mamy $\mathrm{Pf}(J(\mu))=\mu$ i
  \[
  \det\!\big(\mathrm{diag}(J(\mu_1),\dots,J(\mu_k),0_m)\big)
  = \prod_{j=1}^k \mu_j^2,
  \]
  a zatem dla $n$ parzystego $\det(A)=\mathrm{Pf}(A)^2\ge 0$ (przy $\mu_j\ge 0$ otrzymujemy znak „+”).

  
  \item \textbf{(Obliczeniowe) Weryfikacja numeryczna.}
  Wygeneruj losową macierz $A$ przez $A=\tfrac{B-B^T}{2}$.
  \begin{enumerate}[label=(\alph*),itemsep=2pt]
    \item Porównaj wartości osobliwe $A$ z $(\mu_1,\mu_1,\dots)$ z rozkładu blokowego.
    \item Dla $X=A$ sprawdź numerycznie, że $(e^{tX})^T e^{tX}=I$ (ortogonalność).
    \item Zademonstruj empirycznie wzór na błąd z zad.\ 3 dla kilku $r$.
  \end{enumerate}

\end{enumerate}

\section{Rzeczywista postać  Schura}

\begin{theorem}[Rzeczywista postać Schura]
Dla każdej macierzy $A\in\mathbb{R}^{n\times n}$ istnieje ortogonalna $Q\in O(n)$ taka, że
$Q^\top A Q = R$, gdzie $R$ jest macierzą quasi-górnotrójkątną:
na diagonali występują bloki $1\times1$ (dla wartości własnych rzeczywistych)
oraz bloki $2\times2$ postaci
\[
\begin{bmatrix} a & b\\ c & a\end{bmatrix}
\]
reprezentujące sprzężone pary wartości własnych $a \pm i\sqrt{-bc}$.
(W implementacji LAPACK standardowo przyjmuje się konwencję $b\,c<0$.)
\end{theorem}


\begin{remark}[Specjalizacja do $A^T=-A$]
Jeśli $A^T=-A$, to wszystkie wartości własne są czysto urojone lub $0$. 
Stąd w realnej postaci Schura bloki $1\times1$ mogą pojawić się tylko jako $[0]$, 
a każdy blok $2\times2$ ma postać $ \begin{bmatrix} 0 & -\mu\\ \mu & 0\end{bmatrix}=J(\mu)$, $\mu\ge 0$.
To zgadza się z kanoniczną formą blokową z Twierdzenia~1.
\end{remark}

\begin{remark}[Struktura blokowa macierzy $R$]
W rzeczywistej postaci Schura macierz
\[
R = Q^TAQ =
\begin{bmatrix}
B_{11} & B_{12} & B_{13} & \cdots & B_{1k} \\
0      & B_{22} & B_{23} & \cdots & B_{2k} \\
0      & 0      & B_{33} & \cdots & B_{3k} \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
0      & 0      & 0      & \cdots & B_{kk}
\end{bmatrix}
\]
jest górnotrójkątna w sensie bloków.
Każdy blok diagonalny $B_{ii}$ ma wymiar $1\times 1$ (rzeczywista wartość własna)
lub $2\times 2$ (para sprzężonych wartości własnych). 
Dla ustalonego $i$ wszystkie bloki w $i$-tym wierszu $B_{ij}$ (z $j>i$) 
mają tę samą wysokość co $B_{ii}$, a wszystkie bloki w $i$-tej kolumnie (z $j>i$) 
tę samą szerokość. Dzięki temu cała macierz jest górnotrójkątna blokowo.
\end{remark}


\paragraph{Szkic dowodu (związek z Tw.\ 1).}
Realna postać Schura istnieje dla dowolnej macierzy (wyprowadza się ją z zespolonej postaci Schura, grupując pary sprzężone w realne bloki $2\times2$). 
W przypadku $A^T=-A$ wartości własne to $\{0\}\cup\{\pm i\mu_j\}$, więc bloki $2\times2$ muszą być dokładnie $J(\mu_j)$, 
a bloki $1\times1$ zerowe. To jest ta sama struktura, którą uzyskaliśmy w dowodzie kanonicznej formy blokowej.

\paragraph{R: prosta weryfikacja realnych bloków i porównanie z SVD. pakiet expm}



\begin{verbatim}
# ------------------------------------------------------------
# Rzeczywista postać Schura: wizualizacja bloków B_ij
# Wymaga pakietu 'expm' (dla Schur decomposition).
# ------------------------------------------------------------

# 0) Pakiety
if (!requireNamespace("expm", quietly = TRUE)) {
  install.packages("expm")
}
library(expm)

# 1) Pomocnicze:  struktury bloków w real Schur form.
#    W rzeczywistej postaci Schura R jest górnotrójkątna blokowo,
#    a bloki 2x2 rozpoznajemy po niezerowym elemencie na (i+1, i).
detect_block_structure <- function(R, tol = 1e-10) {
  n <- nrow(R)
  i <- 1
  blocks <- list()
  while (i <= n) {
    if (i < n && abs(R[i+1, i]) > tol) {
      # blok 2x2 zaczyna się w i
      blocks[[length(blocks) + 1]] <- list(start = i, end = i + 1, size = 2)
      i <- i + 2
    } else {
      # blok 1x1
      blocks[[length(blocks) + 1]] <- list(start = i, end = i, size = 1)
      i <- i + 1
    }
  }
  blocks
}

# 2) Ładny wydruk bloków diagonalnych i bloków nad-diagonalnych B_ij
print_block_matrix <- function(R, blocks, digits = 3, tol = 1e-10) {
  k <- length(blocks)
  cat(sprintf("Liczba bloków diagonalnych: %d\n", k))
  for (idx in seq_len(k)) {
    b <- blocks[[idx]]
    Bi <- R[b$start:b$end, b$start:b$end, drop = FALSE]
    cat(sprintf("- B_%d%d: %dx%d\n", idx, idx, nrow(Bi), ncol(Bi)))
    print(round(Bi, digits))
  }
  cat("\nBloki nad przekątną (B_ij, i<j):\n")
  for (i in seq_len(k)) {
    for (j in seq_len(k)) {
      if (j > i) {
        ri <- blocks[[i]]$start:blocks[[i]]$end
        cj <- blocks[[j]]$start:blocks[[j]]$end
        Bij <- R[ri, cj, drop = FALSE]
        # wysokość = size(i), szerokość = size(j)
        nz <- if (max(abs(Bij)) > tol) " (potencjalnie != 0)" else ""
        cat(sprintf("  B_%d%d: %dx%d%s,  ||B_%d%d||_F = %.3e\n",
                    i, j, nrow(Bij), ncol(Bij), nz, i, j, norm(Bij, "F")))
      }
    }
  }
}

# 3) Funkcja demka: real Schur dla zadanej macierzy A
demo_real_schur <- function(A, name = "A", show_blocks = TRUE, tol = 1e-10) {
  cat("\n====================================================\n")
  cat(sprintf("Rzeczywista postać Schura dla macierzy %s (n=%d)\n", name, nrow(A)))
  cat("====================================================\n")
  S <- Schur(A)  # expm::Schur
  R <- S$T
  Q <- S$Q
  # Sprawdzenie Q^T A Q = R
  err <- norm(t(Q) %*% A %*% Q - R, "F")
  cat(sprintf("Sprawdzenie: ||Q^T A Q - R||_F = %.3e\n\n", err))
  # Parsowanie bloków
  blocks <- detect_block_structure(R, tol = tol)
  if (show_blocks) {
    print_block_matrix(R, blocks, digits = 3, tol = tol)
  }
  invisible(list(R = R, Q = Q, blocks = blocks))
}

# 4) Przykład 1: macierz rzeczywista ogólna
set.seed(1)
n <- 7
A_general <- matrix(rnorm(n * n), n, n)
res_gen <- demo_real_schur(A_general, name = "A_general")

# 5) Przykład 2: macierz antysymetryczna A^T = -A
B <- matrix(rnorm(n * n), n, n)
A_skew <- 0.5 * (B - t(B))
res_skew <- demo_real_schur(A_skew, name = "A_skew")

# 6) Dla antysymetrycznej: wyciągamy mu_j z bloków 2x2 i porównujemy z SVD
extract_mus_from_skew_R <- function(R, blocks, tol = 1e-8) {
  mus <- c()
  for (b in blocks) {
    if (b$size == 2) {
      Bi <- R[b$start:b$end, b$start:b$end, drop = FALSE]
      # idealnie Bi = [0 -mu; mu 0]; w ogólności [a b; -b a] z a \approx 0, mu \approx b
      a <- Bi[1, 1]; bval <- Bi[1, 2]
      # mu ~ |b|, a powinno być bliskie 0 dla antysymetrycznej
      if (abs(a) > 1e-4) {
        cat(sprintf("Uwaga: blok 2x2 ma a=%.3e (niezerowe przez numerykę)\n", a))
      }
      mus <- c(mus, abs(bval))
    }
  }
  sort(mus, decreasing = TRUE)
}

cat("\n--- Analiza bloków 2x2 dla A_skew ---\n")
R_skew <- res_skew$R
blocks_skew <- res_skew$blocks
mus <- extract_mus_from_skew_R(R_skew, blocks_skew)
cat("mu (z bloków 2x2): ", paste(round(mus, 6), collapse = ", "), "\n")

# Porównanie z SVD: wartości osobliwe powinny być parami (mu, mu, ...)
svd_skew <- svd(A_skew)$d
cat("Singular values (pierwsze 10): ", paste(round(head(svd_skew, 10), 6), collapse = ", "), "\n")

# 7) Sprawdzenie formuły błędu aproksymacji rzędu-2r:  ||A - A_r||_F^2 = 2 * sum_{j>r} mu_j^2
approx_error_sq <- function(mus, r) {
  if (r >= length(mus)) return(0)
  2 * sum(mus[(r + 1):length(mus)]^2)
}

cat("\n--- Błąd aproksymacji (Frobenius) przy zachowaniu r największych bloków J(mu) ---\n")
for (r in 0:min(3, length(mus))) {
  err_th <- approx_error_sq(mus, r)
  cat(sprintf("Teoria: r = %d -> blad_F^2 = %.6f\n", r, err_th))
}

# 8) Bonus: Numeryczna weryfikacja błędu dla A_skew przez obcięcie wartości osobliwych
#    (aproksymacja rzędu-2r odpowiada zachowaniu r par (mu, mu))
numeric_trunc_error_sq <- function(A, r) {
  s <- svd(A)
  # U S V^T, gdzie S = diag(s$d). Zachowujemy 2r największych singular values
  d <- s$d
  keep <- min(2*r, length(d))
  d_trunc <- d
  if (keep < length(d)) d_trunc[(keep+1):length(d)] <- 0
  A_trunc <- s$u %*% (diag(d_trunc, nrow = length(d_trunc))) %*% t(s$v)
  norm(A - A_trunc, "F")^2
}

cat("\n--- Porównanie teorii z obcięciem SVD (zachowujemy 2r sing.val.) ---\n")
for (r in 0:min(3, floor(length(svd_skew)/2))) {
  err_th <- approx_error_sq(mus, r)
  err_num <- numeric_trunc_error_sq(A_skew, r)
  cat(sprintf("r = %d -> teoria: %.6f,  numerycznie (SVD cut): %.6f\n", r, err_th, err_num))
}

cat("\nGotowe. Zwróć uwagę na:\n")
cat("- w A_general: miks bloków 1x1 (rzeczywiste lambda) i 2x2 (pary sprzężone), oraz gwiazdki B_ij nad przekątną.\n")
cat("- w A_skew: bloki 2x2 typu ~J(mu) i zera 1x1; mu z tych bloków = wartości osobliwe (parami).\n")

\end{verbatim}

\section{Prosty program dla rozkładu Schura}
\begin{verbatim}
#powyżej program jest zlozony. Ale w zasadzie jadro jego to
library(expm)

schur_clean <- function(A, tol = 1e-12, digits = 2) {
  S <- Schur(A)
  R <- S$T
  R[Mod(R) < tol] <- 0          # usuń numeryczne „prawie zera” (działa też dla zespolonych)
  print(noquote(format(R, digits = digits, trim = TRUE, scientific = FALSE)))
  invisible(list(Q = S$Q, R = R))
}

schur_clean(A_general)
schur_clean(A_skew)
\end{verbatim}

\paragraph{Zadania (Dodatek).}
\begin{enumerate}[itemsep=3pt]
  \item (Teoria) Używając realnej postaci Schura pokaż, że jeśli $A^T=-A$, 
        to każdy blok $1\times1$ na przekątnej musi być równy $0$.
  \item (Obliczeniowe) Uruchom skrypt dla kilku wymiarów $n$ i zweryfikuj empirycznie,
        że wartości osobliwe $A$ układają się w pary $(\mu_j,\mu_j)$ oraz że
        błąd aproksymacji rzędu-$2r$ równy jest $2\sum_{j>r}\mu_j^2$.

\item \textbf{Eksperyment z postacią Schura.} 
Zmodyfikuj podany program w R tak, aby:
\begin{enumerate}[label=(\alph*),itemsep=2pt]
  \item dla macierzy ogólnej $A$ (losowej) wyznaczyć jej rzeczywistą postać Schura i sprawdzić, że bloki $B_{ij}$ nad przekątną mogą być istotnie niezerowe,
  \item dla macierzy antysymetrycznej $A^T=-A$ przeprowadzić ten sam eksperyment i zwrócić uwagę, że nad przekątną pojawiają się tylko liczby bardzo małe (rzędu $10^{-14}$), wynikające wyłącznie z numeryki,
  \item porównać strukturę bloków w obu przypadkach i wyciągnąć wniosek, dlaczego antysymetryczne macierze mają szczególnie prostą postać Schura.
\end{enumerate}
\end{enumerate}

\section{Grupy i algebry Liego w tle}
\begin{remark}[Grupy i algebry Liego w tle]
W rozdziale pojawiły się dwie klasy grup macierzy:
\begin{itemize}[itemsep=2pt]
  \item \emph{Grupa ortogonalna specjalna} $SO(n)=\{M\in\mathbb{R}^{n\times n}\colon M^TM=I,\quad \det M=1\}$,
  \item \emph{Grupa symplektyczna} $\mathrm{Sp}(2n,\R)=\{M\colon M^T J M=J\}$.
\end{itemize}
Są to przykłady \emph{grup Liego}, czyli grup, które są jednocześnie rozmaitościami gładkimi.  

Każda grupa macierzowa Liego $G$ ma swoją \emph{algebrę Liego} $\mathfrak{g}$ — podprzestrzeń styczną w punkcie jednostki (czyli w $I$), zamkniętą na komutator $[X,Y]=XY-YX$. 

Dla naszych grup:
\[
\mathfrak{so}(n)=\{X\in\R^{n\times n} : X^T=-X\}, \qquad
\mathfrak{sp}(2n,\R)=\{X : X^T J+JX=0\}.
\]

Związek grupy i algebry zapewnia \emph{odwzorowanie wykładnicze}
\[
\exp\colon \mathfrak{g}\to G, \quad X\mapsto e^X.
\]
Dla dowolnego $X$ w algebrze Liego mamy $e^{tX}\in G$ dla wszystkich $t\in\R$.  
W drugą stronę, z samej grupy $G$ można odtworzyć algebrę jako zbiór wszystkich
$X$, 
\[
\mathfrak{g}=\{X=c'(0): c:\R\to G,\quad \rm{smooth},\quad c(0)=I \}.
\] 
\end{remark}

\begin{remark}[Odwzorowanie wykładnicze]
Dla każdej algebry Liego $\mathfrak{g}$ istnieje odwzorowanie
\[
\exp\colon \mathfrak{g}\to G, \quad X\mapsto e^X,
\]
które dla $X\in\mathfrak{g}$ daje krzywą $e^{tX}\subset G$. 
Nie jest ono jednak w ogólności ani różnowartościowe, ani „na”. 

\begin{itemize}[itemsep=2pt]
  \item W przypadku $\mathfrak{so}(n)$ obraz $\exp$ to $SO(n)$, czyli $exp(\mathfrak{so}(n))=SO(n)$. Dowód tego faktu wynika z rozkładu macierzy rzeczywistych antysymetrycznych na bloki.
        Zadanie do sprawdzenia  $\exp(0)=I=\exp(2\pi J)$ dla $J=\begin{bmatrix}0&-1\\1&0\end{bmatrix}$. Skorzystaj z rozwinięcia funkcji trygonometrycznych.
  \item W przypadku $\mathfrak{sp}(2n,\R)$ obrazem $\exp$  NIE JEST cała grupa $\mathrm{Sp}(2n,\R)$. \emph{Fakt:} Każdy element $A\in \mathrm{Sp}(2n,\R)$ można zapisać jako iloczyn dwóch
wykładników $A=\exp(X)\exp(Y)$ z $X,Y\in\mathfrak{sp}(2n,\R)$.
Sprawdzenie braku różnowartościowości
poniżej

\begin{verbatim}

library(expm)

J <- matrix(c(0,-1, 1,0), 2, 2)

# X w sp(2,R): X^T J + J X = 0
X <- matrix(c(0,-1, 1,0), 2, 2)

is_hamiltonian <- function(X,J) max(abs(t(X)%*%J + J%*%X)) < 1e-12
cat("X w sp(2,R)? ", is_hamiltonian(X, J), "\n")

A_t <- function(t) expm(t*X)

check_sympl <- function(A,J) max(abs(t(A)%*%J%*%A - J)) < 1e-10

for (t in c(0, 0.5, 1, pi, 2*pi)) {
  A <- A_t(t)
  cat(sprintf("t=%5.2f : symplektyczna? %s\n", t, check_sympl(A, J)))
}

# Brak iniektywności (okresowość)
A0   <- A_t(0)
A2pi <- A_t(2*pi)
cat("e^{0X} == e^{2*pi*X}? ", max(abs(A0 - A2pi)) < 1e-10, "\n")


\end{verbatim}
  
  
        
\end{itemize}
\end{remark}


\end{document}
